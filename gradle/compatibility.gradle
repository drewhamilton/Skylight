import me.champeau.gradle.japicmp.JapicmpTask

buildscript {
    dependencies {
        classpath "me.champeau.gradle:japicmp-gradle-plugin:$japicmp_version"
    }
    repositories {
        gradlePluginPortal()
    }
}

def compatibleVersion = '0.10.0'
def failIfIncompatible = false

configurations {
    baseline
    latest
}

dependencies {
    baseline("$group:$artifact:$compatibleVersion") {
        transitive false
        force true
        for (module in compatibility.excludedModules)
            exclude module: module
    }
    latest(project(path: ":$project.name")) {
        for (module in compatibility.excludedModules)
            exclude module: module
    }
}

apply plugin: 'me.champeau.gradle.japicmp'
task japicmp(type: JapicmpTask) {
    oldClasspath = configurations.baseline.incoming.artifactView { config ->
        config.attributes { container ->
            container.attribute(Attribute.of("artifactType", String.class), "jar")
        }
    }.artifacts.artifactFiles

    newClasspath = configurations.latest.incoming.artifactView { config ->
        config.attributes { container ->
            container.attribute(Attribute.of("artifactType", String.class), "jar")
        }
    }.artifacts.artifactFiles

    // TODO: Explicitly exclude Kotlin internal classes:
    classExcludes = [

    ]

    onlyBinaryIncompatibleModified true
    failOnModification failIfIncompatible
    txtOutputFile = file("$buildDir/reports/japi.txt")

    ignoreMissingClasses compatibility.ignoreMissingClasses
}

check.dependsOn(japicmp)
build.dependsOn(check)
